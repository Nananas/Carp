
(def LEFT 0)
(def RIGHT 1)
(def UP 2)
(def DOWN 3)

(defmacro ++ [:rest strs]
  (string-join- strs))

(def i 0) ;; act as captured value

(defn lambda-cellfromnumber [c]
  (=> (bit-shift-right i c)
      (bit-and 1)))

(defn cell-from-number [j]
  (do
    (set! i j) ;; set captured value
    (repeat-indexed 9
      lambda-cellfromnumber)))


(defn genallcells []
  (repeat-indexed (pow 2 9) cell-from-number))


(defn validcell [c]
  (match-array c
    [0 1 _  1 _ _  _ _ _]   false
    [_ 1 0  _ _ 1  _ _ _]   false
    [_ _ _  _ _ 1  _ 1 0]   false
    [_ _ _  1 _ _  0 1 _]   false
    [_ 1 _  1 _ 1  _ 1 _]   false
    [0 0 0  0 1 0  0 0 0]   true
    [_ _ _  _ 1 _  _ _ _]   false   
    [0 0 0  0 0 0  0 0 0]   false
    [_ _ _  _ _ _  _ _ _]   true
    false))


(defn cell-direction [cell dir]
  (match-array cell 
    [a b c  d _ e  f g h] 
      (case @dir
        LEFT  [a d f]
        RIGHT [c e h]
        UP    [a b c]
        DOWN  [f g h]
        [])
    []))

(defn flip-dir [dir]
  (case @dir
    UP    DOWN
    DOWN  UP
    LEFT  RIGHT
    RIGHT LEFT
    -1))

(defn connects [c1 c2 dir]
  (= &(cell-direction c1 dir) &(cell-direction c2 &(flip-dir dir))))

(def cell (the (Array Int) []))
(def direction &0)

(defn L-connects [c]
  (the Bool (connects &cell c direction)))

(defn matchable-cells [c dir cells]
  (do
    (set! direction dir)
    (set! cell @c)
    (filter L-connects @cells)))
    

(defn positive? [x]
  (>= @x 0))

(def exclude-dir -1)
(defn exclude [x]
  (/= @x exclude-dir))

(defn available-directions [cell excl-dir]
  (let-do [r []
           NO -1]
    (set! exclude-dir excl-dir)
    (set! r (filter positive? ;; lambda
        (=> r
          (push-back (match-array cell [1 _ _ 1 _ _ 1 _ _] NO LEFT))
          (push-back (match-array cell [_ _ 1 _ _ 1 _ _ 1] NO RIGHT))
          (push-back (match-array cell [1 1 1 _ _ _ _ _ _] NO UP))
          (push-back (match-array cell [_ _ _ _ _ _ 1 1 1] NO DOWN)))))
    ; (println &(str (= &r &[excl-dir])))
    (if (= &r &[excl-dir])
      r
      (filter exclude r))))


(defn shifted-pos [pos dir]
  (let-do [new (Pos.init @(Pos.x pos) @(Pos.y pos))]
    (with Pos
      (case @dir
        UP    (set-y! &new (- @(y pos) CS))
        DOWN  (set-y! &new (+ @(y pos) CS))
        LEFT  (set-x! &new (- @(x pos) CS))
        RIGHT (set-x! &new (+ @(x pos) CS))
      ()))
    new))


(defmacro pick-random [xs]
  (list 'nth xs (list 'random-between 0 (list 'count xs))))

(defn int-or [a b]
  (if (and (= a 1) (= b 1)) 
    1
    0))

(defn int-and [a b]
  (if (and (= a 0) (= b 0)) 
    0
    1))

(defn blend-cell [c1 c2]
  (let-do [cnew c1]
    (for [i 0 (count c1)]
      (if (= i 4)
        (aset! cnew i (int-and @(nth c1 i) @(nth c2 i)))
        (aset! cnew i (int-or @(nth c1 i) @(nth c2 i)))))
    @cnew))


;; TODO: make a separate side-tunnel-dig
(defn dig [valid-cells nbr-digs-left excl-dir tunnel]
  (do
    (while (> nbr-digs-left 0)
      (do
        (let [prev       (nth &tunnel (dec (count &tunnel)))
              prevcell   (Cell.data prev)
              prevpos    (Cell.pos  prev)
              av-dir     &(available-directions prevcell excl-dir)]
          (if (= (count av-dir) 0) 
            (break)
            (let [dir        (pick-random av-dir)
                  valid-next (matchable-cells prevcell dir valid-cells)
                  nextcell   @(pick-random &valid-next)
                  nextpos    &(shifted-pos prevpos dir)]
              (do
                ; (println &(str av-dir))
                (for [i 0 (count &tunnel)]
                  (let [ipos  (=> (nth &tunnel i) Cell.pos)
                        icell (=> (nth &tunnel i) Cell.data)]
                    (when (and (= (Pos.x ipos) (Pos.x nextpos))
                               (= (Pos.y ipos) (Pos.y nextpos)))
                      (if (= i 0) ;; do not blend first cell
                        (set! nextcell @icell)
                        (==> (blend-cell icell &nextcell)
                             (set! nextcell))))))

                (==> (Cell.init @&nextcell @nextpos)
                     (push-back tunnel)
                     (set! tunnel))

                (when (= (random-between 0 50) 1)
                  (let-do [tmppos prevpos]
                    (set! tunnel (dig valid-cells 20 -1 tunnel))
                    (set! nbr-digs-left (- nbr-digs-left 20))
                    (set! prevpos tmppos)))

                ))))

        (update! nbr-digs-left dec)))
    tunnel))

(defn get-dimentions [tunnel]
  (let [w 0
        h 0]
    (do
      (for [c 0 (count tunnel)]
        (do
          (set! w (max w @(=> (Cell.pos (nth tunnel c)) Pos.x)))
          (set! h (max h @(=> (Cell.pos (nth tunnel c)) Pos.y)))))
      (Dim.init w h))))

(defmacro map-reduce [init xs f]
  (list 'let init
    (list 'do
      (list 'for (array 'i '0 (list 'count xs))
        f)
      (list 'Dim.init 'w 'h))))

(defn get-dimentions-2 [tunnel]
  (map-reduce [w 0 h 0] tunnel
    (do
      (set! w (max w @(=> (Cell.pos (nth tunnel i)) Pos.x)))
      (set! h (max h @(=> (Cell.pos (nth tunnel i)) Pos.y))))))
  ; (let [w 0]
    ; (for [c 0 (count tunnel)]
      ; (set! w (max w (=> (Cell.pos c) Pos.x)))))

; (defn blit-to-grid [tunnel grid]
;   (let [gw (count grid)]
;     (for [ti 0 (count tunnel)]
;       (let [cell (nth tunnel ti)
;             xx @(=> (Cell.pos cell) (Pos.x))
;             yy @(=> (Cell.pos cell) (Pos.y))]

;         (for [ci 0 (count (Cell.data cell))]
;           (let [tile (nth (Cell.data cell) ci)
;                 x (mod i 3)
;                 y (/ i 3)
;                 index (+ (+ (* gw xx) x) (+ (* yy gw) (* y gw)))]
;               (aset! grid index tile)))))))
;               ; (do 
;                 ; (if (= @(nth cell i) 1)
;                   ; (SDL_SetRenderDrawColor renderer 0 0 0 255)
;                   ; (SDL_SetRenderDrawColor renderer 255 255 255 255))
;                 ; (SDL_RenderFillRect renderer (address 
;                   ; (make-rect 
;                     ; (- (* (+ xx (* x TS)) SCALE) cx)
;                     ; (- (* (+ yy (* y TS)) SCALE) cy)
;                     ; (* TS SCALE)
;                     ; (* TS SCALE)))))))))
;   