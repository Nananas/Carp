
(def LEFT 0)
(def RIGHT 1)
(def UP 2)
(def DOWN 3)

(defmacro ++ [:rest strs]
  (string-join- strs))

(def i 0) ;; act as captured value

(defn lambda-cellfromnumber [c]
  (=> (bit-shift-right i c)
      (bit-and 1)))

(defn cell-from-number [j]
  (do
    (set! i j) ;; set captured value
    (repeat-indexed 9
      lambda-cellfromnumber)))


(defn genallcells []
  (repeat-indexed (pow 2 9) cell-from-number))


(defn validcell [c]
  (match-array c
    [0 1 _  1 _ _  _ _ _]   false
    [_ 1 0  _ _ 1  _ _ _]   false
    [_ _ _  _ _ 1  _ 1 0]   false
    [_ _ _  1 _ _  0 1 _]   false
    [_ 1 _  1 _ 1  _ 1 _]   false
    [0 0 0  0 1 0  0 0 0]   true
    [_ _ _  _ 1 _  _ _ _]   false   
    [0 0 0  0 0 0  0 0 0]   false
    [_ _ _  _ _ _  _ _ _]   true
    false))


(defn cell-direction [cell dir]
  (match-array cell 
    [a b c  d _ e  f g h] 
      (case @dir
        LEFT  [a d f]
        RIGHT [c e h]
        UP    [a b c]
        DOWN  [f g h]
        [])
    []))

(defn flip-dir [dir]
  (case @dir
    UP    DOWN
    DOWN  UP
    LEFT  RIGHT
    RIGHT LEFT
    -1))

(defn connects [c1 c2 dir]
  (= &(cell-direction c1 dir) &(cell-direction c2 &(flip-dir dir))))

(def cell (the (Array Int) []))
(def direction &0)

(defn L-connects [c]
  (the Bool (connects &cell c direction)))

(defn matchable-cells [c dir cells]
  (do
    (set! direction dir)
    (set! cell @c)
    (filter L-connects @cells)))
    

(defn positive? [x]
  (>= @x 0))

(def exclude-dir -1)
(defn exclude [x]
  (/= @x exclude-dir))

(defn available-directions [cell excl-dir]
  (let-do [r []
           NO -1]
    (set! exclude-dir excl-dir)
    (set! r (filter positive? ;; lambda
        (=> r
          (push-back (match-array cell [1 _ _ 1 _ _ 1 _ _] NO LEFT))
          (push-back (match-array cell [_ _ 1 _ _ 1 _ _ 1] NO RIGHT))
          (push-back (match-array cell [1 1 1 _ _ _ _ _ _] NO UP))
          (push-back (match-array cell [_ _ _ _ _ _ 1 1 1] NO DOWN)))))
    ; (println &(str (= &r &[excl-dir])))
    (if (= &r &[excl-dir])
      r
      (filter exclude r))))


(defn shifted-pos [pos dir]
  (let-do [new (Pos.init @(Pos.x pos) @(Pos.y pos))]
    (with Pos
      (case @dir
        UP    (set-y! &new (dec @(y pos)))
        DOWN  (set-y! &new (inc @(y pos)))
        LEFT  (set-x! &new (dec @(x pos)))
        RIGHT (set-x! &new (inc @(x pos)))
      ()))
    new))


(defmacro pick-random [xs]
  (list 'nth xs (list 'random-between 0 (list 'count xs))))

(defn int-or [a b]
  (if (and (= a 1) (= b 1)) 
    1
    0))

(defn int-and [a b]
  (if (and (= a 0) (= b 0)) 
    0
    1))

(defn blend-cell [c1 c2]
  (let-do [cnew c1]
    (for [i 0 (count c1)]
      (if (= i 4)
        (aset! cnew i (int-and @(nth c1 i) @(nth c2 i)))
        (aset! cnew i (int-or @(nth c1 i) @(nth c2 i)))))
    @cnew))


;; TODO: make a separate side-tunnel-dig
(defn dig [valid-cells nbr-digs-left excl-dir tunnel]
  (do
    (while (> nbr-digs-left 0)
      (do
        (let [prev       (nth &tunnel (dec (count &tunnel)))
              prevcell   (Cell.data prev)
              prevpos    (Cell.pos  prev)
              av-dir     &(available-directions prevcell excl-dir)]
          (if (= (count av-dir) 0) 
            (break)
            (let [dir        (pick-random av-dir)
                  valid-next (matchable-cells prevcell dir valid-cells)
                  nextcell   @(pick-random &valid-next)
                  nextpos    &(shifted-pos prevpos dir)]
              (do
                ; (println &(str av-dir))
                (for [i 0 (count &tunnel)]
                  (let [ipos  (=> (nth &tunnel i) Cell.pos)
                        icell (=> (nth &tunnel i) Cell.data)]
                    (when (and (= (Pos.x ipos) (Pos.x nextpos))
                               (= (Pos.y ipos) (Pos.y nextpos)))
                      (if (= i 0) ;; do not blend first cell
                        (set! nextcell @icell)
                        (==> (blend-cell icell &nextcell)
                             (set! nextcell))))))

                (==> (Cell.init @&nextcell @nextpos)
                     (push-back tunnel)
                     (set! tunnel))

                (when (= (random-between 0 50) 1)
                  (let-do [tmppos prevpos]
                    (set! tunnel (dig valid-cells 20 -1 tunnel))
                    (set! nbr-digs-left (- nbr-digs-left 20))
                    (set! prevpos tmppos)))

                ))))

        (update! nbr-digs-left dec)))
    tunnel))

(deftype Tuple [one Int two Int three Int four Int])
(defmacro <> [one two three four]
  ; (do (macro-log a)
  ; (macro-log b)
  ; (macro-log c)
  ; (macro-log d)
  (list 'Tuple.init one two three four))
(defmacro <1> [t]
  (list 'Tuple.one t))
(defmacro <2> [t]
  (list 'Tuple.two t))
(defmacro <3> [t]
  (list 'Tuple.three t))
(defmacro <4> [t]
  (list 'Tuple.four t))

(defn get-dimentions [tunnel]
  (let [sx 0 sy 0 ex 0 ey 0]
    (do
      (for [c 0 (count tunnel)]
        (let-do [cell (nth tunnel c)]
          ; (println &(str @(=> (Cell.pos cell) Pos.y)))
          (set! sx (min sx @(=> (Cell.pos cell) Pos.x)))
          (set! sy (min sy @(=> (Cell.pos cell) Pos.y)))
          (set! ex (max ex @(=> (Cell.pos cell) Pos.x)))
          (set! ey (max ey @(=> (Cell.pos cell) Pos.y)))))
      (<> (* sx 3) (* sy 3) (+ (* ex 3) 3) (+ (* ey 3) 3)))))

; (defmacro map-reduce2 [init xs f]
;   (list 'let init
;     (list 'do
;       (list 'for (array 'i '0 (list 'count xs))
;         f)
;       (list '<> 'w 'h))))

;; HACK, but exactly the same as a for loop
; (defn get-dimentions [tunnel]
;   (map-reduce2 [w 0 h 0] tunnel
;     (do
;       (set! w (max w @(=> (Cell.pos (nth tunnel i)) Pos.x)))
;       (set! h (max h @(=> (Cell.pos (nth tunnel i)) Pos.y))))))

;; TODO: fix player position is now incorrect
(defn blit-to-grid [tunnel]
  (let [dimentions (get-dimentions tunnel)
        dsx @(<1> &dimentions)
        dsy @(<2> &dimentions)
        dex @(<3> &dimentions)
        dey @(<4> &dimentions)
        w (- dex dsx)
        h (- dey dsy)
        grid (replicate h &(replicate w &0))]
    (do
      (for [ti 0 (count tunnel)]
        (let [cell (nth tunnel ti)
              xx (- (* @(=> (Cell.pos cell) (Pos.x)) 3) dsx)
              yy (- (* @(=> (Cell.pos cell) (Pos.y)) 3) dsy)]
          (for [ci 0 (count (Cell.data cell))]
            (let [cx (mod ci 3)
                  cy (/ ci 3)
                  x (+ xx cx)
                  y (+ yy cy)
                  row (nth &grid y)
                  value @(nth (Cell.data cell) ci)]
              (aset! row x (- 1 value))))))
      grid)))

(defn get-start-pos [tunnel]
  (let [dimentions (get-dimentions tunnel)
        dsx @(<1> &dimentions)
        dsy @(<2> &dimentions)
        dex @(<3> &dimentions)
        dey @(<4> &dimentions)]
    (Pos.init 
      (+ (- @(=> (nth tunnel 0) Cell.pos Pos.x) dsx) 1)
      (+ (- @(=> (nth tunnel 0) Cell.pos Pos.y) dsy) 1))))

(defn print-grid [grid]
  (for [y 0 (count grid)]
    (do
      (for [x 0 (count (nth grid 0))]
        (print &(str @(nth (nth grid y) x))))
      (println ""))))
