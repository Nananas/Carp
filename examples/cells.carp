(use Int)
(use Array)
(use IO)
(use String)
(use System)

(defmacro ++ [:rest strs]
  (string-join- strs))

(system-include "bench.h")

; (local-include "raw.h")
(add-cflag "-O3")

(load "sdl.carp")
(load "sdl_image.carp")
(load "match.carp")

(def App-width 400)
(def App-height 700)
(def Half-width 200)
(def Half-height 350)


(load "state.carp")
(load "render.carp")
(load "mapgen.carp")

(register get-time-elapsed (Fn [] Double))

; (defn surrounding-grid [dx dy state]
;  )

(defn move-player [dx dy state]
  (with State
  (do
    (Player.set-x! (player state) (+ @(Player.x (player state)) dx))
    (Player.set-y! (player state) (+ @(Player.y (player state)) dy)))))


(defn main []
  (do
    (seed (time))
    (let-do [app (app-init @"Cells" App-width App-height)
            rend (app-renderer app)
            cells (filter validcell (genallcells))
            start-cell (Cell.init [0 0 0 0 0 0 0 1 0] (Pos.init 0 0))
            tunnel (dig &cells 50 LEFT [@&start-cell])

            grid (blit-to-grid &tunnel)
            player-pos (get-start-pos &tunnel)
            ; (>> dw dh << )
            ; grid (blit-to-grid tunnel dw dh)
            ; _ (println &(str &grid))
            ; _ (print-grid &grid)
            _ (println &(str &player-pos))
            state (state-new grid @(Pos.x &player-pos) @(Pos.y &player-pos))
            ; texture (IMG_LoadTexture rend (cstr "./resources/tree.png"))
            ; grid (replicate @(Dim.x &dimentions) &(replicate @(Dim.y &dimentions) &0))
            ; grid (replicate (* @(Dim.x &dimentions) @(Dim.y &dimentions)) &0)
            ]
      
      (while true
        (do

          (handle-events &app rend &state)
          (when @(State.mousedown &state) 
            (do
              (State.set-mousedown! &state false)
              (println &(fmt "MOUSE DOWN AT %i %i" @(State.mx &state) @(State.my &state)))
              
              (let [mx @(State.mx &state)
                    my @(State.my &state)]
                (for [i 0 (count (State.buttons &state))]
                  (let [b (nth (State.buttons &state) i)]
                    (with Button
                      (when (and* 
                            (> mx @(x b))
                            (> my @(y b))
                            (< mx (+ @(x b) @(w b)))
                            (< my (+ @(y b) @(h b))))
                        (case @(id b)
                          2   (move-player 0 -1 &state)
                          5   (move-player -1 0 &state)
                          7   (move-player 1  0 &state)
                          10  (move-player 0  1 &state)
                          6   (move-player 0  0 &state)
                          (println &(str @(id b)))))))))))


          (update-state &state)

          (when (= (count (State.data &state)) 0)
            ; (do
              ; (State.set-data! &state (blit-to-grid &(dig &cells 100 LEFT [@&start-cell])))
            (let [tunnel (dig &cells 100 LEFT [@&start-cell])
                  player-pos (get-start-pos &tunnel)]
              (set! state (state-new (blit-to-grid &tunnel) @(Pos.x &player-pos) @(Pos.y &player-pos)))))

          (SDL_SetRenderDrawBlendMode rend SDL_BLENDMODE_BLEND)
          (SDL_SetRenderDrawColor rend 0 0 0 0)
          (SDL_RenderClear rend)

          (render-map (State.data &state) @(State.cx &state) @(State.cy &state) rend)
          ; (for [i 0 (count (State.data &state))]
          ;   (let [n (nth (State.data &state) i)]
          ;     (render-cell n
          ;       ; (Cell.data n)
          ;       ; @(Pos.x (Cell.pos n))
          ;       ; @(Pos.y (Cell.pos n))
          ;       rend
          ;       @(State.cx &state)
          ;       @(State.cy &state))))

          (render-player 
            @(=> (State.player &state) (Player.x)) 
            @(=> (State.player &state) (Player.y))
            rend
            @(State.cx &state)
            @(State.cy &state))
          ; (render-grid @(State.cx &state) @(State.cy &state) rend)

          (render-UI rend (State.buttons &state))


          ; (SDL_RenderCopy rend texture (address (make-rect 0 0 100 100)) (address (make-rect 100 100 100 100)))
          (SDL_RenderPresent rend)
          (SDL_Delay 16))))
    ()))
