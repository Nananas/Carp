;; The '_>' macro is an extended `=>`/`==>` macro, where the `_` symbol is used
;; as position marker

(defdynamic replace-with-internal [old new curr expr]
  (if (= (count expr) 0)
    curr
    (replace-with-internal old new
      (cons
        (if (and (symbol? (last expr)) (= (last expr) old)) 
          new 
          (last expr))
        curr)
      (all-but-last expr))))

(defdynamic replace-with [old new form]
  (replace-with-internal old new () form))

(defdynamic replace-with-recursive-internal [old new curr expr]
  (if (= (count expr) 0)
    curr
    (replace-with-recursive-internal old new
      (cons
        (if (list? (last expr))
          (replace-with-recursive-internal old new
            () (last expr))
          (if (and (symbol? (last expr)) (= (last expr) old)) 
            new
            (last expr)))
        curr)
      (all-but-last expr))))


(defdynamic replace-with-recursive [old new form]
  (replace-with-recursive-internal old new () form))


(defdynamic _>-internal [curr forms]
  (do
    ; (macro-log forms)
    ; (macro-log (list? forms))
    ; (macro-log (car forms))
    ; (macro-log (count forms))
  (if (= (count forms) 0)
    curr
    ; (if (not (list? (car forms)))
      (_>-internal 
        (replace-with-recursive '_  curr 
          (if (list? (car forms))
            (car forms)
            (list (car forms))))
        (cdr forms))))
)

(defmacro _> [a :rest forms]
  ; (macro-log-return
  (if (contains-recursive a '_)
    (macro-error "Found '_' inside first argument. Did you forget to include it?")
      (_>-internal a forms)))
  ; )

; (deftype A [a Int b Int])

; (use IO)
; (use Array)

; (load "Test.carp")
; (use Test)

; (defn test-#> []
;   (let [c 1]
;     (> c
;       (+ # 5)
;       (/ 10 #)
;       str)))

; (defn main []
;   (with-test test
;     (assert-true test 
;                 (test-#>) 
;                 "#> macro")
    
;     (print-test-results test)))



