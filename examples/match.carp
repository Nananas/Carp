;; The 'match-array' macro takes an optional list of reference symbols, the array to match,
;; and then an odd number of arguments, where each pair describes a match 
;; and the last form is the 'else' branch.
;;
;; An array pattern consists of a list, containing one or more:
;; - value
;; - a symbol
;; - '_' (wildcard)
;;
;; A pattern will be matched when all non-wildcard values are equal, and the size of the array
;; is equal to the pattern count
;;
;; Destructuring is done on all symbols, not in the reference list if it was specified.

(defmacro match-array [:rest forms]
  (if (array? (car forms))
    (build-match-internal (car forms) (cadr forms) (cddr forms))
    (build-match-internal () (car forms) (cdr forms))))

(defdynamic build-match-internal [refs xs forms]
  (if (= (count forms) 0)
    (list)
    (if (= (count forms) 2)
      (macro-error "ERROR")
      (if (= (count forms) 1)
        (car forms)
        (list 'if (match-array-pattern refs xs (car forms))
          (destr-array refs xs (car forms) (cadr forms))
          (build-match-internal refs xs (cddr forms)))))))

(defdynamic match-array-pattern [refs xs p]
  (cons 'and*
    (cons
      (list 'Int.= (list 'Array.count xs) (count p))
      (build-pattern () refs xs 0 p))))

(defdynamic build-pattern [current refs xs i p]
  (if (= (count p) 0)
      current ;; return
    (if (and (symbol? (car p)) (not (contains refs (car p))))
      (build-pattern current refs xs (inc i) (cdr p)) ;; skip
      (build-pattern 
        (cons
          (list '= (car p)
            (list 'copy (list 'Array.nth xs i)))
          current)
        refs xs (inc i) (cdr p)))))
  
(defdynamic destr-array [refs xs pattern return]
  (list 'let
      (list-to-array (build-from-pattern () refs xs 0 pattern) [])
    return))

(defdynamic build-from-pattern [current refs xs i p]
  (if (= (count p) 0)
    current
    (if (or (not (symbol? (car p))) 
        (and (symbol? (car p)) (or (= (car p) '_) (contains refs (car p)))))
      (build-from-pattern current refs xs (inc i) (cdr p)) ;; skip
      (build-from-pattern 
        (cons
          (car p) (cons (list 'copy (list 'Array.nth xs i))
          current))
        refs xs (inc i) (cdr p)))))
