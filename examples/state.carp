

(deftype Pos [x Int y Int])
(deftype Cell [data (Array Int) pos Pos])
(deftype Player [x Int y Int])
(deftype Button [x Int y Int w Int h Int id Int down Bool active Bool])
(deftype State 
  [data (Array (Array Int))  ;; map
   cx Int 
   cy Int
   kup Bool
   kdown Bool
   kleft Bool
   kright Bool
   mx Int
   my Int
   mousedown Bool
   player Player
   buttons (Array Button)])

; (definterface <1> (λ [a] b))
; (definterface <2> (λ [a] b))
; (defmodule Tuple
  ; (deftype (T2 a b) [one a two b])
  ; (deftype (Tuple3 a b c) [one a two b three c])

  ; (defn <1> [d]
    ; @(Tuple.T2.one d))

; )

; (defmacro <> [:rest forms]
;   (macro-log-return (if (= (count forms) 2)
;     (list 'Tuple.T2.init (car forms) (cadr forms))
;     (if (= (count forms) 3)
;       (list 'Tuple.T2.init (car forms) (cadr forms) (caddr forms))
;       ()))))




; (defn button-callback [button]
;   (do
;     (Button.set-down! button true)
;     (println "Button callback")))

(defn state-new [data px py]
  (State.init data -200 -150 false false false false 0 0 false (Player.init px py) 
    (let-do [bs []]
            (for [ix 0 4]
              (for [iy 0 3]
                (set! bs (push-back bs (Button.init (+ 10 (* ix 100)) (+ (+ Half-height 20) (* iy 100)) 80 80 (+ ix (* iy 4)) false false)))))
            bs)))

(defn handle-events [app rend state]
  (let [event (SDL_Event_init)]
    (while (SDL_PollEvent (address event))
      (let [et (event-type &event)]
        (with State
          (case et 
            SDL_QUIT             (quit app)
            SDL_MOUSEBUTTONDOWN  
                (let-do [ms (get-mouse-state)] 
                  (set-mx! state @(MouseState.x &ms))
                  (set-my! state @(MouseState.y &ms))
                  (set-mousedown! state true))

            SDL_KEYDOWN
              (case (event-keycode &event)
                SDLK_LEFT (do
                    (set-kleft! state true))

                SDLK_RIGHT (do
                    (set-kright! state true))

                SDLK_UP (do
                    (set-kup! state true))

                SDLK_DOWN (do
                    (set-kdown! state true))

                SDLK_r (do
                    (set-data! state [])
                    (set-cx! state -200)
                    (set-cy! state -150))

                ())

            SDL_KEYUP
              (case (event-keycode &event)
                SDLK_LEFT (do
                    (set-kleft! state false))

                SDLK_RIGHT (do
                    (set-kright! state false))

                SDLK_UP (do
                    (set-kup! state false))

                SDLK_DOWN (do
                    (set-kdown! state false))

                ())

            ()))))))


(defn update-state [state]
  (with State
    (do
      (when @(kleft state)
        (set-cx! state (- @(cx state) 10)))
      (when @(kright state)
        (set-cx! state (+ @(cx state) 10)))
      (when @(kup state)
        (set-cy! state (- @(cy state) 10)))
      (when @(kdown state)
        (set-cy! state (+ @(cy state) 10))))))